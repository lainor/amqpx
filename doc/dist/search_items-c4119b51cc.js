searchNodes=[{"ref":"Amqpx.Consumer.html","title":"Amqpx.Consumer","type":"behaviour","doc":"Generic implementation of AMQP consumer"},{"ref":"Amqpx.Consumer.html#child_spec/1","title":"Amqpx.Consumer.child_spec/1","type":"function","doc":"Returns a specification to start this module under a supervisor. See Supervisor."},{"ref":"Amqpx.Consumer.html#c:handle_message/2","title":"Amqpx.Consumer.handle_message/2","type":"callback","doc":""},{"ref":"Amqpx.Consumer.html#init/1","title":"Amqpx.Consumer.init/1","type":"function","doc":"Invoked when the server is started. start_link/3 or start/3 will block until it returns. init_arg is the argument term (second argument) passed to start_link/3. Returning {:ok, state} will cause start_link/3 to return {:ok, pid} and the process to enter its loop. Returning {:ok, state, timeout} is similar to {:ok, state} except handle_info(:timeout, state) will be called after timeout milliseconds if no messages are received within the timeout. Returning {:ok, state, :hibernate} is similar to {:ok, state} except the process is hibernated before entering the loop. See c:handle_call/3 for more information on hibernation. Returning {:ok, state, {:continue, continue}} is similar to {:ok, state} except that immediately after entering the loop the c:handle_continue/2 callback will be invoked with the value continue as first argument. Returning :ignore will cause start_link/3 to return :ignore and the process will exit normally without entering the loop or calling c:terminate/2. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the GenServer. The remainder of the supervision tree will be started and so the GenServer should not be required by other processes. It can be started later with Supervisor.restart_child/2 as the child specification is saved in the parent supervisor. The main use cases for this are: The GenServer is disabled by configuration but might be enabled later. An error occurred and it will be handled by a different mechanism than the Supervisor. Likely this approach involves calling Supervisor.restart_child/2 after a delay to attempt a restart. Returning {:stop, reason} will cause start_link/3 to return {:error, reason} and the process to exit with reason reason without entering the loop or calling c:terminate/2. Callback implementation for GenServer.init/1."},{"ref":"Amqpx.Consumer.html#c:setup/1","title":"Amqpx.Consumer.setup/1","type":"callback","doc":""},{"ref":"Amqpx.Consumer.html#start_link/1","title":"Amqpx.Consumer.start_link/1","type":"function","doc":""},{"ref":"Amqpx.Consumer.html#t:state/0","title":"Amqpx.Consumer.state/0","type":"type","doc":""},{"ref":"Amqpx.Producer.html","title":"Amqpx.Producer","type":"module","doc":"Generic implementation of AMQP producer"},{"ref":"Amqpx.Producer.html#child_spec/1","title":"Amqpx.Producer.child_spec/1","type":"function","doc":"Returns a specification to start this module under a supervisor. See Supervisor."},{"ref":"Amqpx.Producer.html#init/1","title":"Amqpx.Producer.init/1","type":"function","doc":"Invoked when the server is started. start_link/3 or start/3 will block until it returns. init_arg is the argument term (second argument) passed to start_link/3. Returning {:ok, state} will cause start_link/3 to return {:ok, pid} and the process to enter its loop. Returning {:ok, state, timeout} is similar to {:ok, state} except handle_info(:timeout, state) will be called after timeout milliseconds if no messages are received within the timeout. Returning {:ok, state, :hibernate} is similar to {:ok, state} except the process is hibernated before entering the loop. See c:handle_call/3 for more information on hibernation. Returning {:ok, state, {:continue, continue}} is similar to {:ok, state} except that immediately after entering the loop the c:handle_continue/2 callback will be invoked with the value continue as first argument. Returning :ignore will cause start_link/3 to return :ignore and the process will exit normally without entering the loop or calling c:terminate/2. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the GenServer. The remainder of the supervision tree will be started and so the GenServer should not be required by other processes. It can be started later with Supervisor.restart_child/2 as the child specification is saved in the parent supervisor. The main use cases for this are: The GenServer is disabled by configuration but might be enabled later. An error occurred and it will be handled by a different mechanism than the Supervisor. Likely this approach involves calling Supervisor.restart_child/2 after a delay to attempt a restart. Returning {:stop, reason} will cause start_link/3 to return {:error, reason} and the process to exit with reason reason without entering the loop or calling c:terminate/2. Callback implementation for GenServer.init/1."},{"ref":"Amqpx.Producer.html#publish/1","title":"Amqpx.Producer.publish/1","type":"function","doc":""},{"ref":"Amqpx.Producer.html#start_link/1","title":"Amqpx.Producer.start_link/1","type":"function","doc":""},{"ref":"Amqpx.Producer.html#t:state/0","title":"Amqpx.Producer.state/0","type":"type","doc":""}]